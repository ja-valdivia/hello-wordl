# MEF LSO Presto SDN Plug-in

This new SDN plug-in introduces the OSM MEF LSO Presto Connector with examples that can be used live with
OpenDaylight Unimgr.


## Prerequisites

The MEF-Presto WIM connector assumes that the Presto SDK demo VM is running OpenDaylight Unimgr and mininet.

### OpenDaylight

The VM can be downloaded from the following locations: 

* Presto-SDK.zip (https://mef.box.com/s/h5j78genqwx2y4z7msho6119wxqnpffe)
* Presto-SDK.z01 (https://mef.box.com/s/2rhbl3ct3wqkszm06ootbe31frjhyhps)

Login: mef-dev
Password: mef-dev

Here are the commands to unzip after you have downloaded both the files

* zip -s 0 Presto-SDK.zip --out Presto-SDK-full.zip
* unzip Presto-SDK-full.zip 

If you need to manually start OpenDaylight, these are the steps:

#### Start OpenDaylight

```sh
% cd unimgr-karaf-0.3.1.SNAPSHOT
% ./bin/karaf
Apache Karaf starting up. Press Enter to open the shell now...
100% [========================================================================]

Karaf started in 17s. Bundle stats: 338 active, 338 total

    ________                       ________                .__  .__       .__     __
    \_____  \ ______   ____   ____ \______ \ _____  ___.__.|  | |__| ____ |  |___/  |
     /   |   \\____ \_/ __ \ /    \ |    |  \\__  \<   |  ||  | |  |/ ___\|  |  \   __\
    /    |    \  |_> >  ___/|   |  \|    `   \/ __ \\___  ||  |_|  / /_/  >   Y  \  |
    \_______  /   __/ \___  >___|  /_______  (____  / ____||____/__\___  /|___|  /__|
            \/|__|        \/     \/        \/     \/\/            /_____/      \/


Hit '<tab>' for a list of available commands
and '[cmd] --help' for help on a specific command.
Hit '<ctrl-d>' or type 'system:shutdown' or 'logout' to shutdown OpenDaylight.

opendaylight-user@root>
```
#### Enable OVS Driver in OpenDaylight

```sh
opendaylight-user@root>feature:install odl-unimgr-ovs-driver
```

### Mininet

From GitHub clone MEF-LSO Presto SDk

```sh
git clone https://github.com/MEF-GIT/MEF-LSO-Presto-SDK.git
```

Start Mininet in a docker container:

```sh
docker run -it --rm -p 6699:6640 -v /home/osm/MEF-LSO-Presto-SDK/documentation/tutorial/mininet:/root/config --privileged iwaseyusuke/mininet
```

Get into the docker container and inside the container start mininet:

```sh
% osm@osm:~/osm_code/branches/v7/RO/RO/osm_ro/wim$ docker ps | grep mininet
0b21e7cd1a43        iwaseyusuke/mininet                        "/ENTRYPOINT.sh"         23 hours ago        Up 23 hours             6633/tcp, 6653/tcp, 0.0.0.0:6699->6640/tcp   musing_ellis
% docker exec -ti 0b21e7cd1a43 bash
root@0b21e7cd1a43:~# python config/create_topology.py 192.168.56.105
** Creating network
*** Adding controller
Unable to contact the remote controller at 127.0.0.1:6633
*** Adding hosts:
h1 h2 
*** Adding switches:
s1 s2 s3 
*** Adding links:
(h1, s1) (h2, s2) (s1, s3) (s2, s3) 
*** Configuring hosts
h1 h2 
*** Starting controller
c0 
*** Starting 3 switches
s1 s2 s3 ...
*** Starting CLI:
mininet> 
```

### Register OVS with OpenDaylight

The RESTCONF call looks like this:

```
POST /restconf/config/network-topology:network-topology/topology/ovsdb:1
Authorization: basic-auth
Content-Type: application/json
```

The JSON request looks like this:

```json
{
    "node": [
        {
            "node-id": "odl",
            "connection-info": {
              "remote-ip": "127.0.0.1",
              "remote-port": 6640
            }
        }
    ]
}
```
You can use the tutorial script into the MEF-Presto SDK installation:

```json
$ cd ~/MEF-LSO-Presto-SDK/documentation/tutorial
$ ./tutorial.sh init
```

# Example

We are going to use an example using a NS with two VNFs in two diferents datacenters, simulating a datacenter in Madrid and the other in Barcelona.

You can run the new SDN plug-in following the following steps.

## Step 1 - Create two VNFs Descriptors

Create the Madrid datacenter VNF descriptor 

```
vnfd:vnfd-catalog:
    vnfd:
    -   id: madrid-mefpresto_vnfd
        name: madrid-mefpresto_vnfd
        short-name: madrid-mefpresto_vnfd
        description: Generated by OSM package generator
        vendor: OSM
        version: '1.0'

        # Place the logo as png in icons directory and provide the name here
        # logo: <update, optional>

        # Management interface
        mgmt-interface:
            cp: madrid-cp0

        # Atleast one VDU need to be specified
        vdu:
        # Additional VDUs can be created by copying the
        # VDU descriptor below
        -   id: madrid-mefpresto_vnfd-VM
            name: madrid-mefpresto_vnfd-VM
            description: madrid-mefpresto_vnfd-VM
            count: 1

            # Flavour of the VM to be instantiated for the VDU
            vm-flavor:
                vcpu-count: 1
                memory-mb: 1024
                storage-gb: 10

            # Image including the full path
            image: 'ubuntu1604'

            interface:
            # Specify the external interfaces
            # There can be multiple interfaces defined
            -   name: eth0
                type: EXTERNAL
                virtual-interface:
                    type: PARAVIRT
                external-connection-point-ref: madrid-cp0
        connection-point:
        -   name: madrid-cp0
            port-security-enabled: false
```

Create the Barcelona datacenter VNF descriptor 

```
vnfd:vnfd-catalog:
    vnfd:
    -   id: barna-mefpresto_vnfd
        name: barna-mefpresto_vnfd
        short-name: barna-mefpresto_vnfd
        description: Generated by OSM package generator
        vendor: OSM
        version: '1.0'

        # Place the logo as png in icons directory and provide the name here
        # logo: <update, optional>

        # Management interface
        mgmt-interface:
            cp: barna-cp0

        # Atleast one VDU need to be specified
        vdu:
        # Additional VDUs can be created by copying the
        # VDU descriptor below
        -   id: barna-mefpresto_vnfd-VM
            name: barna-mefpresto_vnfd-VM
            description: barna-mefpresto_vnfd-VM
            count: 1

            # Flavour of the VM to be instantiated for the VDU
            vm-flavor:
                vcpu-count: 1
                memory-mb: 1024
                storage-gb: 10

            # Image including the full path
            image: 'ubuntu1604'

            interface:
            # Specify the external interfaces
            # There can be multiple interfaces defined
            -   name: eth0
                type: EXTERNAL
                virtual-interface:
                    type: PARAVIRT
                external-connection-point-ref: barna-cp0
        connection-point:
        -   name: barna-cp0
            port-security-enabled: false
```

Install the VNF descriptors:

```
$ osm vnfd-create madrid-mefpresto_vnfd.tar.gz
$ osm vnfd-create barcelona-mefpresto_vnfd.tar.gz
```

## Step 2 - Create two VIMs 

Create the Madrid and Barcelona openstack VIMs to simulate the two datacenters.

```
osm vim-create \
--name madrid-datacenter \
--auth_url http://10.95.85.101:5000/v3 \
--tenant admin \
--user admin \
--password psa \
--account_type openstack \
--description "Simulacion de datacenter de madrid" \
--config '{"external_connections": [ {"condition": { "name": "external" }, "vim_external_port": { "switch":"openflow:1", "port":"1" }},
 {"condition": { "name": "test-vlan-mefpresto" }, "vim_external_port": { "switch":"openflow:1", "port":"2" }}]}'

osm vim-create \
--name barcelona-datacenter \
--auth_url http://10.95.85.101:5000/v3 \
--tenant admin \
--user admin \
--password psa \
--account_type openstack \
--description "Simulacion de datacenter de barcelona" \
--config '{"external_connections": [ {"condition": { "name": "external" }, "vim_external_port": { "switch":"openflow:1", "port":"1" }},
 {"condition": { "name": "test-vlan-mefpresto" }, "vim_external_port": { "switch":"openflow:1", "port":"2" }}]}'
```

## Step 3 - Create the MEF-Presto WIM 

Create the new MEF-Presto WIM.

```
osm wim-create \
--name WIM-mefpresto \
--url http://192.168.122.149:8181 \
--user admin \
--password admin \
--wim_type mefpresto \
--description "MEF Presto API WIM" \
--wim_port_mapping ./wim_port_mapping.yaml \
--config '{"conn-constraint": { "service-type": "FAKE", "service-level": "BEST_EFFORT" }}'
```

We use the OpenDaylight URL controller and the wim port mappings yaml file to describe the WAN port mappings.

```
- datacenter_name: "madrid-datacenter"
  pop_wan_mappings:
    - device_id: "dev_mad_1"
      device_interface_id: "dev_int_mad_1"
      switch_dpid: "openflow:1"
      switch_port: 1
      service_endpoint_id: "sip:ovs-node:s1:s1-eth1"
    - device_id: "dev_mad_2"
      device_interface_id: "dev_int_mad_2"
      switch_dpid: "openflow:1"
      switch_port: 2
      service_endpoint_id: "sip:ovs-node:s1:s1-eth2"
- datacenter_name: "barcelona-datacenter"
  pop_wan_mappings:
    - device_id: "dev_bar_1"
      device_interface_id: "dev_int_bar_1"
      switch_dpid: "openflow:1"
      switch_port: 1
      service_endpoint_id: "sip:ovs-node:s2:s2-eth1"
    - device_id: "dev_bar_2"
      device_interface_id: "dev_int_bar_2"
      switch_dpid: "openflow:1"
      switch_port: 2
      service_endpoint_id: "sip:ovs-node:s2:s2-eth2"
```

## Step 4 - Create the NS

We are going to use two diferent NS using diferents network, one without VLAN and the other with VLAN.

### Step 4.1 - NS with "external" network

Create the new MEF-Presto WIM

The RESTCONF call looks like this:
```
GET /restconf/operational/tapi-common:context/tapi-topology:topology/mef:presto-nrp-topology
Authorization: basic-auth
Content-Type: application/json
```

You can get the topology using curl in a shell like this:

```sh
curl -XGET --basic -u admin:admin \
  http://localhost:8181/restconf/operational/tapi-common:context/tapi-topology:topology/mef:presto-nrp-topology
```

The response in this test environment contains a single *abstract* node which represents the OVS
device, with a list of node edge points. Any two of these node edge points can be connected by a
connectivity service. This JSON response is shortened for readability.

```json
{
    "topology": {
        "layer-protocol-name": [
            "ETH"
        ],
        "uuid": "mef:presto-nrp-topology",
        "node": [
            {
                "uuid": "mef:presto-nrp-abstract-node",
                "layer-protocol-name": [
                    "ETH"
                ],
                "encap-topology": {
                    "topology-id": "mef:presto-nrp-topology-system"
                },
                "owned-node-edge-point": [
                    {
                        "uuid": "ovs-node:s2:s2-eth1",
                        "layer-protocol-name": "ETH",
                        "link-port-role": "SYMMETRIC",
                        "mapped-service-interface-point": [
                            {
                                "service-interface-point-id": "sip:ovs-node:s2:s2-eth1"
                            }
                        ],
                        "link-port-direction": "BIDIRECTIONAL"
                    },
/*[ ... CUT ...]*/
                    {
                        "uuid": "ovs-node:s1:s1-eth1",
                        "layer-protocol-name": "ETH",
                        "link-port-role": "SYMMETRIC",
                        "mapped-service-interface-point": [
                            {
                                "service-interface-point-id": "sip:ovs-node:s1:s1-eth1"
                            }
                        ],
                        "link-port-direction": "BIDIRECTIONAL"
                    },
                    {
                        "uuid": "ovs-node:s1:s1-eth2",
                        "layer-protocol-name": "ETH",
                        "link-port-role": "SYMMETRIC",
                        "mapped-service-interface-point": [
                            {
                                "service-interface-point-id": "sip:ovs-node:s1:s1-eth2"
                            }
                        ],
                        "link-port-direction": "BIDIRECTIONAL"
                    }
/*[ ... CUT ...]*/
                ]
            }
        ]
    }
}
```

You can run this tutorial step with the *tutorial.sh* helper:

```sh
% ./tutorial.sh step1
{"tapi-topology:topology":[{"uuid":"mef:presto-nrp-topology","node":[ ...
```

## Step 2 - Create a Connectivity Service

The RESTCONF call looks like this:
```
POST /restconf/operations/tapi-connectivity:create-connectivity-service
Authorization: basic-auth
Content-Type: application/json
```

The JSON request looks like this:
```json
{
  "input": {
    "end-point": [
      {
        "service-interface-point": {
          "service-interface-point-id" :"sip:ovs-node:s1:s1-eth1"
          
        },
        "direction": "BIDIRECTIONAL",
        "layer-protocol-name": "ETH",
        "nrp-carrier-eth-connectivity-end-point-resource": {
          "ce-vlan-id-list-and-untag": {
            "vlan-id":[
              {
                "vlan-id": 301
              }
            ]
          }
        }
      },
      {
        "service-interface-point": {
          "service-interface-point-id" :"sip:ovs-node:s2:s2-eth1"
        },
        "direction": "BIDIRECTIONAL",
        "layer-protocol-name": "ETH",
        "nrp-carrier-eth-connectivity-end-point-resource": {
          "ce-vlan-id-list-and-untag": {
            "vlan-id":[
              {
                "vlan-id": 301
              }
            ]
          }
        }
      }
    ],
    "conn-constraint": {
      "service-type": "POINT_TO_POINT_CONNECTIVITY",
      "service-level": "BEST_EFFORT"
    },
    "nrp-interface:nrp-carrier-eth-connectivity-resource": {
      "max-frame-size": "2000"
    }
  }
}
```

You can run this tutorial step with the *tutorial.sh* helper:

```sh
% ./tutorial.sh step2
{"output":{"service":{"uuid":"cs:15d08dd666c:-7f69bf18","connection": ...
```

## Step 3 - Get List of Connectivity Services

The RESTCONF call looks like this:
```
POST /restconf/operations/tapi-connectivity:get-connectivity-service-list
Authorization: basic-auth
Content-Type: application/json
```

The JSON response looks like this:

```json
{
    "output": {
        "service": {
            "uuid": "cs:16253332dff:25aeaf3d",
            "connection": [
                "conn:mef:presto-nrp-abstract-node:16253332dff:25aeaf3d"
            ],
            "end-point": [
                {
                    "local-id": "sep:-1898313e",
                    "service-interface-point": {
                        "service-interface-point-id": "sip:ovs-node:s1:s1-eth1"
                    },
                    "direction": "BIDIRECTIONAL",
                    "layer-protocol-name": "ETH",
                    "nrp-interface:nrp-carrier-eth-connectivity-end-point-resource": {
                        "ce-vlan-id-list-and-untag": {
                            "vlan-id": [
                                {
                                    "vlan-id": 301
                                }
                            ]
                        }
                    },
                    "role": "SYMMETRIC"
                },
                {
                    "local-id": "sep:7d611662",
                    "service-interface-point": {
                        "service-interface-point-id": "sip:ovs-node:s2:s2-eth1"
                    },
                    "direction": "BIDIRECTIONAL",
                    "layer-protocol-name": "ETH",
                    "nrp-interface:nrp-carrier-eth-connectivity-end-point-resource": {
                        "ce-vlan-id-list-and-untag": {
                            "vlan-id": [
                                {
                                    "vlan-id": 301
                                }
                            ]
                        }
                    },
                    "role": "SYMMETRIC"
                }
            ]
        }
    }
}
```

You can run this tutorial step with the *tutorial.sh* helper:

```sh
% ./tutorial.sh step3
{"output":{"service":[{"uuid":"cs:15d08ad16d5:6f00d57b" ...
```

## Step 4 - Delete a Connectivity Service

The RESTCONF call looks like this:
```
POST /restconf/operations/tapi-connectivity:delete-connectivity-service
Authorization: basic-auth
Content-Type: application/json
```

The JSON request payload looks like this:

```json
{
  "input" : {
    "service-id-or-name" : "{uuid}"
  }
}
```

You can run this tutorial step with the *tutorial.sh* helper - take the service-uuid from the output in step 3:

```sh
% ./tutorial.sh step4 <service-uuid>
```
